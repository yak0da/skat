1. Напишите (в очередной раз ☹) класс Square(x, y, w) со следующими свойствами:

x и y — это координаты левой нижней вершины квадрата, а w — его ширина

Дополнительно поддерживаются поля h (равное w), s (равное площади квадрата) и center (кортеж с координатами середины квадрата)

Все поля, кроме s, можно менять

попытка изменить площадь ни к чему не приводит ничего не происходит
изменение центра или координат вершины влияют друг на друга, а ширина и высота остаются прежней
изменение ширины или высоты не влияют на координаты вершины, но сдвигают центр
Поле center должно поддерживать операцию добавления кортежа из двух чисел — это смещение середины квадрата

При сопоставлении в операторе match / case все эти поля можно использовать как именные параметры, а x, y и w — как позиционные

Input:

for x, y, w in (1, 2, 0), (1, 1, 7), (3, 4, 10), (5, 3, 6):
    Sq = Square(x, y, w)
    Sq.center += -1, -1
    match Sq:
        case Square(_, _, 0):
            print("Zero square")
        case Square(0, 0, _):
            print("Started from 0")
        case Square(s=100):
            print("10x10 square")
        case Square(center=c) if c[0] == round(c[0]) and c[1] == round(c[1]):
            print("Even-sized square")
Output:

Zero square
Started from 0
10x10 square
Even-sized square



2. Написать класс-параметрический декоратор Fix(n), с помощью которого все вещественные (как позиционные, так и именные) параметры произвольной декорируемой функции, а также её возвращаемое значение, округляются до n-го знака после запятой (1 ⩽ n ⩽ 16). Если какие-то параметры функции оказались не вещественными, или не вещественно возвращаемое значение, эти объекты не меняются.

<!> Требуется использовать @wraps

Input:
@Fix(4)
def aver(*args, sign=1):
    return sum(args)*sign

print(aver(2.45675901, 3.22656321, 3.432654345, 4.075463224, sign=-1))

Output:
-13.1916